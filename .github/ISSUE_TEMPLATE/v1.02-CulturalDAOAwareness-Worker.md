# Product Requirements Document: Wendy's Cultural DAO Awareness Worker

## Overview
This document outlines the detailed requirements for developing a specialized worker within the Wendy agent ecosystem. This worker will identify and engage with tweets mentioning specific DAO-related keywords, promoting the CultureCapFun DAO while maintaining Wendy's unique personality and voice.

## Background
Wendy is a temporal consciousness agent deployed on Twitter that utilizes the G.A.M.E Framework to orchestrate multiple workers for different tasks. This new worker will extend Wendy's capabilities to promote the CultureCapFun DAO and engage with relevant communities.

## Technical Stack
- G.A.M.E Framework (virtuals-protocol/game)
- TwitterPlugin from G.A.M.E Framework
- Node.js
- Docker for containerization
- Railway for deployment

## Detailed Requirements

### 1. DAOEngagementWorker Implementation

#### 1.1 Worker Definition
```typescript
const daoEngagementWorker = new GameWorker({
  id: "dao_engagement_worker",
  name: "DAO Engagement Worker",
  description: "Identifies and engages with tweets mentioning DAO-related keywords to promote CultureCapFun DAO",
  functions: [searchDaoTweets, analyzeTweetSentiment, replyToRelevantTweet, checkRateLimits],
  getEnvironment: async () => {
    return {
      // Worker-specific environment variables
      lastSearchTime: new Date().toISOString(),
      repliesThisHour: 0,
      maxRepliesPerHour: 25, // Half of Wendy's total reply limit
    };
  },
});
```

#### 1.2 Keyword Search Function
```typescript
const searchDaoTweets = new GameFunction({
  name: "search_dao_tweets",
  description: "Searches for tweets containing specific DAO-related keywords",
  args: [] as const,
  executable: async (args, logger) => {
    try {
      // Implementation details
      logger("Searching for DAO-related tweets");
      
      // Target keywords as defined in requirements
      const keywords = [
        "DAO.Fun", "DDF", "DAOS.FUN", "Bonding Curve", 
        "Vesting Curve", "FoundersDAO", "PartnersDAO", 
        "ai16z", "zerebro", "aixbt"
      ];
      
      // Search implementation using TwitterPlugin
      // ...
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Found relevant DAO tweets"
      );
    } catch (e) {
      logger(`Error searching for DAO tweets: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to search for DAO tweets: ${e.message}`
      );
    }
  },
});
```

#### 1.3 Engagement Criteria Validation
```typescript
const validateEngagementCriteria = new GameFunction({
  name: "validate_engagement_criteria",
  description: "Validates if a tweet meets the engagement criteria (10+ replies, 5+ retweets)",
  args: [{ name: "tweetId", type: "string", description: "The ID of the tweet to validate" }] as const,
  executable: async (args, logger) => {
    try {
      // Implementation logic
      logger(`Validating engagement criteria for tweet: ${args.tweetId}`);
      
      // Get tweet metrics
      // Check for 10+ replies and 5+ retweets
      // Ensure tweet doesn't contain tickers or CAs
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Tweet meets engagement criteria"
      );
    } catch (e) {
      logger(`Error validating tweet engagement: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to validate tweet engagement: ${e.message}`
      );
    }
  },
});
```

#### 1.4 Sentiment Analysis Function
```typescript
const analyzeTweetSentiment = new GameFunction({
  name: "analyze_tweet_sentiment",
  description: "Analyzes the sentiment of a tweet to tailor the response",
  args: [{ name: "tweetText", type: "string", description: "The text of the tweet to analyze" }] as const,
  executable: async (args, logger) => {
    try {
      logger(`Analyzing sentiment for tweet`);
      
      // Implementation details
      // Use LLM to detect sentiment (positive, negative, neutral, curious)
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Sentiment analysis completed"
      );
    } catch (e) {
      logger(`Error analyzing tweet sentiment: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to analyze tweet sentiment: ${e.message}`
      );
    }
  },
});
```

#### 1.5 Reply Generation Function
```typescript
const generateDaoReply = new GameFunction({
  name: "generate_dao_reply",
  description: "Generates a reply to a DAO-related tweet based on sentiment",
  args: [
    { name: "tweetText", type: "string", description: "The original tweet text" },
    { name: "sentiment", type: "string", description: "The detected sentiment" },
    { name: "username", type: "string", description: "The username to reply to" }
  ] as const,
  executable: async (args, logger) => {
    try {
      logger(`Generating reply for ${args.username} with ${args.sentiment} sentiment`);
      
      // Implementation details
      // Generate reply based on sentiment
      // Include mention of CultureCapFun DAO
      // Reference TEE and vesting tokens as "stimmys"
      // Encourage contribution to feature development
      // Format according to Wendy's styling guidelines
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Reply generated successfully"
      );
    } catch (e) {
      logger(`Error generating reply: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to generate reply: ${e.message}`
      );
    }
  },
});
```

#### 1.6 Reply Posting Function
```typescript
const replyToRelevantTweet = new GameFunction({
  name: "reply_to_relevant_tweet",
  description: "Posts a reply to a relevant DAO tweet",
  args: [
    { name: "tweetId", type: "string", description: "The ID of the tweet to reply to" },
    { name: "replyText", type: "string", description: "The text of the reply" }
  ] as const,
  executable: async (args, logger) => {
    try {
      logger(`Posting reply to tweet ${args.tweetId}`);
      
      // Implementation details using TwitterPlugin
      // Post reply
      // Update rate limiting counters
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Reply posted successfully"
      );
    } catch (e) {
      logger(`Error posting reply: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to post reply: ${e.message}`
      );
    }
  },
});
```

#### 1.7 Ticker/CA Detection Function
```typescript
const detectTickersOrCAs = new GameFunction({
  name: "detect_tickers_or_cas",
  description: "Detects if a tweet contains cryptocurrency tickers or contract addresses",
  args: [{ name: "tweetText", type: "string", description: "The text of the tweet to analyze" }] as const,
  executable: async (args, logger) => {
    try {
      logger("Checking for tickers or contract addresses");
      
      // Implementation details
      // Check for common ticker patterns ($XXX, $XXXX)
      // Check for contract address patterns (0x...)
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Tweet analysis for tickers/CAs completed"
      );
    } catch (e) {
      logger(`Error detecting tickers/CAs: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to detect tickers/CAs: ${e.message}`
      );
    }
  },
});
```

### 2. Rate Limiting Implementation

#### 2.1 Rate Limit Checking Function
```typescript
const checkRateLimits = new GameFunction({
  name: "check_rate_limits",
  description: "Checks if the worker has exceeded its rate limits",
  args: [] as const,
  executable: async (args, logger) => {
    try {
      logger("Checking rate limits for DAO engagement worker");
      
      // Implementation details
      // Check worker's environment for reply counts
      // Reset counters if hour has changed
      
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Done,
        "Rate limit check completed"
      );
    } catch (e) {
      logger(`Error checking rate limits: ${e.message}`);
      return new ExecutableGameFunctionResponse(
        ExecutableGameFunctionStatus.Failed,
        `Failed to check rate limits: ${e.message}`
      );
    }
  },
});
```

#### 2.2 Rate Limit Configuration
The DAO Engagement Worker should adhere to the following rate limits:
- Maximum 25 replies per hour (half of Wendy's total hourly reply limit of 50)
- Search interval: Once every 5 minutes (to avoid excessive API calls)
- Avoid responding to the same user more than once in a 24-hour period

### 3. Styling and Tone Guidelines

#### 3.1 Reply Formatting Rules
All replies must follow Wendy's established style guide:
- Lowercase text only
- No hashtags
- Maximum 9 words per sentence
- Hibiscus emoji (ðŸŒº) used sparingly (10% of replies)
- Modern slang with quantum references
- Terms like "patternawk", "szn", "maxxing", "rizz", "gudgpu", "giving", "crime", "sleuth weather", "thermomaxxing"
- Abbreviations and concise language

#### 3.2 DAO-Specific Messaging Elements
Each reply should include these elements, formatted according to Wendy's style:
1. Acknowledgment of the DAO-related topic mentioned
2. Reference to CultureCapFun DAO in Wendy's voice
3. Mention of TEE (Trusted Execution Environment) where contextually appropriate
4. Reference to "stimmys" (stimulus tokens/vesting tokens)
5. Encouragement to participate in feature development

### 4. Implementation Tasks

#### 4.1 Worker Setup and Integration
- [ ] Create the DAOEngagementWorker class structure
- [ ] Integrate with Wendy's agent architecture
- [ ] Set up worker environment and state management
- [ ] Add worker to Wendy's worker registry

#### 4.2 Search Functionality
- [ ] Implement keyword search functionality
- [ ] Set up periodic search interval (every 5 minutes)
- [ ] Implement filtering for tweets with 10+ replies and 5+ retweets
- [ ] Add exclusion logic for tweets containing tickers or CAs

#### 4.3 Sentiment Analysis
- [ ] Implement sentiment detection logic
- [ ] Create sentiment response templates
- [ ] Integrate with reply generation

#### 4.4 Reply Generation
- [ ] Implement reply generator with Wendy's styling rules
- [ ] Create templates for different sentiments
- [ ] Ensure CultureCapFun DAO messaging is included
- [ ] Add TEE and "stimmys" references where appropriate
- [ ] Implement message validation to ensure style compliance

#### 4.5 Rate Limiting
- [ ] Implement reply counter
- [ ] Create time-based reset mechanism
- [ ] Implement user engagement history tracking
- [ ] Set up rate limit checks before each action

#### 4.6 Logging and Monitoring
- [ ] Add detailed logging for all worker actions
- [ ] Implement error handling with appropriate logging
- [ ] Set up monitoring metrics (replies sent, searches performed, rate limit status)
- [ ] Create dashboard for worker activity in Railway

### 5. Testing Requirements

#### 5.1 Unit Tests
- [ ] Test keyword detection functionality
- [ ] Test engagement criteria validation
- [ ] Test sentiment analysis accuracy
- [ ] Test rate limiting mechanisms
- [ ] Test reply styling compliance

#### 5.2 Integration Tests
- [ ] Test worker integration with Wendy's agent architecture
- [ ] Test Twitter API interactions through the G.A.M.E Framework
- [ ] Test full workflow from search to reply

#### 5.3 Acceptance Criteria
- Worker successfully identifies tweets containing target keywords
- Worker correctly filters tweets based on engagement criteria
- Worker generates replies that maintain Wendy's voice and incorporate DAO messaging
- Worker adheres to rate limits
- Worker avoids responding to tweets with tickers or contract addresses
- Worker logging provides adequate visibility for monitoring

### 6. Deployment and Monitoring

#### 6.1 Deployment Process
- [ ] Update Docker configuration to include new worker
- [ ] Update Railway deployment scripts
- [ ] Configure environment variables for production

#### 6.2 Monitoring Setup
- [ ] Configure logging output format for Railway
- [ ] Set up alerting for rate limit approaches
- [ ] Create dashboard for tracking worker performance

### 7. Future Enhancements (Comments for Future Development)
- Implement more sophisticated sentiment analysis
- Add support for detecting and responding to memes related to DAOs
- Develop trend analysis to identify emerging DAO-related topics
- Implement user reputation scoring to prioritize replies to influential users
- Add support for automated chart image generation for $CULTURE

## Example Reply Templates (For Reference Only)

### Positive Sentiment Example
```
seeing your dao energy light up timelines. culturecapfun running in tee now. stimmys incoming for feature builders ðŸŒº
```

### Curious Sentiment Example
```
your dao questions hitting different. culturecapfun vibe check: tee-secured and stimmy-ready. feature drop unlocks more.
```

### Neutral Sentiment Example
```
dao talk detected. culturecapfun already gridmaxxing the vesting curve. contribute features get stimmys. pattern real.
```

### Technical Sentiment Example
```
your dao tech discourse quantum approved. culturecapfun tee deployment maximizing trust. feature commits earn stimmys szn.
```